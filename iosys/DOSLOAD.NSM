						%INCLUDE "UTIL.NSM"
						%INCLUDE "DEF.NSM"
						%INCLUDE "TOWNSDEF.NSM"
						%INCLUDE "IODEF.NSM"


; If YSDOS.SYS is in the root dir of the boot device, it loads YSDOS.
; Otherwise, look for C:\MSDOS.SYS.

; If BOOTDRV:YAMAND.COM is available, it will launch YAMAND.COM.
; Otherwise, look for C:\COMMAND.COM

						CPU		386
						BITS	16


CONFIGSYS_SEG			EQU		0A800h
CONFIGSYS_SIZE_LIMIT	EQU		8000h

DOSLOADER_EXE_SEG		EQU		0B800h
DOSLOADER_SIZE			EQU		 8000h
ROOTDIR_OFFSET			EQU		00800h	; Rootdir loaded at BOOTSECT_SEG:ROOTDIR_OFFSET

BOOTSECT_SEG			EQU		08000h

PARTITION_TABLE_LBA		EQU		1
PARTITION_TABLE_FIRST_PARTITION_LBA		EQU		6
PARTITION_TABLE_NUM_SECTORS				EQU		6
PARTITION_TABLE_FIRST_PARTITION			EQU		020h
PARTITION_ENTRY_SIZE					EQU		030h

CODE					SEGMENT	USE16


						; Input
						;   BX    Boot device as passed from the IPL
						;   GS:SI Pointer to the first CONDEV
						;   FS:DI CDS Pointer
						JMP		SHORT REALENTRY

BOOT_DEVICE:			DW		0	; +02h
DOSSEG:					DW		0	; +04h Segment YSDOS.SYS is loaded
BOOT_DRIVE:				DB		0	; +06h
						DB		0
SYSVARS_PTR				DW		0	; +08h
SYSVARS_SEG				DW		0	; +0Ah
CDS_PTR					DD		0	; +0Ch

						DW		0	; +10h
						DW		0
HD_PARTITION_TABLE_PTR	DD		0	; +14h  IO.SYS uses this offset.  Do not change.
NUM_HD_BPB_PTR			DD		0	; +18h  IO.SYS uses this offset.  Do not change.
ADDITIONAL_IO_BUF_PTR	DD		0	; +1Ch  IO.SYS uses this offset.  Do not change.

TEXT_POS:
TEXT_Y:					DB		8
TEXT_X:					DB		0

CONFIG_SYS_BUFFERS		DB		8
CONFIG_SYS_FILES		DB		20

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

REALENTRY:
						MOV		CS:[BOOT_DEVICE],BX
						SHL		EBX,16
						MOV		CS:[BOOT_PARTITION],BX

						MOV		EBX,0FF0000h
						CALL	PALETTE_DEBUG

						; Apparently MSCDEX.EXE is assuming it is loaded above 1000H.
						; During the initialization, it subtracts 1000H from the segment, and then access offset FFF0H of that
						; segment to verify integrity.  However, if the segment is lower than 1000H, it underflows to FF??H, then
						; 80386+ CPU will read above 1MB if accessing FF??H:FFF0H.
						; Therefore, make DOSSEG at least 1000H.
						MOV		AX,CS
						CMP		AX,1000H
						JAE		FORCE_DOS_1000H_OR_ABOVE
						MOV		AX,1000H
FORCE_DOS_1000H_OR_ABOVE:
						MOV		CS:[DOSSEG],AX  ; DOS will be loaded this location.

						MOV		CS:[CONDEV_PTR],SI
						MOV		CS:[CONDEV_PTR+2],GS

						MOV		CS:[CDS_PTR],DI
						MOV		CS:[CDS_PTR+2],FS

						PUSH	CS
						POP		DS
						MOV		AX,DOSLOADER_EXE_SEG
						MOV		ES,AX

						MOV		CX,DOSLOADER_SIZE/4
						XOR		SI,SI
						XOR		DI,DI
						CLD
						REP		MOVSD

						DB		0EAH ; JMPF
						DW		CLONE_ENTRY
						DW		DOSLOADER_EXE_SEG


						; Will be executed in DOSLOADER_EXE_SEG
CLONE_ENTRY:
						MOV		EBX,0FF00FFh
						CALL	PALETTE_DEBUG


						MOV		AH,BIOSCMD_COMMON_INIT
						INT		0AEH	; Initialize Interrupt Manager.
						;  This must be done first.  It sets secondary PIC Special Fully Nested Mode.

						XOR		AH,AH
						INT		90H						; Keyboard BIOS

						MOV		AH,BIOSCMD_COMMON_INIT	; Console BIOS
						INT		91H

						MOV		AH,BIOSCMD_COMMON_INIT	; Disk BIOS
						INT		93H

						MOV		AH,BIOSCMD_COMMON_INIT	; Timer BIOS
						INT		97H

						MOV		AH,BIOSCMD_COMMON_INIT	; RS232C BIOS
						INT		9BH


						MOV		EBX,0FFFF00h
						CALL	PALETTE_DEBUG


						MOV		SI,MSG_INT_INITIALIZED
						CALL	TEXT_MESSAGE


						; Apparently INT 4DH should always be enabled.
						PUSH	EAX
						MOV		DI,SS
						MOV		DS,DI
						MOV		DI,SP
						MOV		AH,03H	; Get INT-Enabled Flags
						INT		0AEH

						MOV		EAX,DS:[DI]
						OR		EAX,INTMANBIOS_INT0D_FLAG
						MOV		DS:[DI],EAX

						MOV		AH,02H	; Set INT-Enabled Flags
						INT		0AEH
						POP		EAX


						MOV		BX,CS:[BOOT_DEVICE]
						CMP		BL,BOOTDEV_SCSICD
						JNE		NOT_BOOT_FROM_SCSICD

						MOV		AX,(DISKBIOS_CMD_EXT_ENABLE_SCSI_REDIR*0x100)+DISKBIOS_CD
						MOV		DL,BH
						INT		93H
						JB		INSTALL_SCSI_CD_FAILED
						MOV		BX,BOOTDEV_CD
						MOV		CS:[BOOT_DEVICE],BX

NOT_BOOT_FROM_SCSICD:
						CMP		BL,BOOTDEV_FD
						JNE		NOT_BOOT_FROM_FD
						CALL	LOAD_DOS_FROM_FD
						JB		TRY_LOAD_DOS_FROM_ROM
						JMP		YSDOS_LOADED

NOT_BOOT_FROM_FD:
						CMP		BL,BOOTDEV_CD
						JNE		NOT_BOOT_FROM_CD
						CALL	LOAD_DOS_FROM_CD
						JB		TRY_LOAD_DOS_FROM_ROM
						JMP		YSDOS_LOADED

NOT_BOOT_FROM_CD:
						CMP		BL,BOOTDEV_HD
						JNE		NOT_BOOT_FROM_HD
						CALL	LOAD_DOS_FROM_HD
						JB		TRY_LOAD_DOS_FROM_ROM
						JMP		YSDOS_LOADED


NOT_BOOT_FROM_HD:		JMP		NOT_BOOT_FROM_HD	; Where is this booting from?


TRY_LOAD_DOS_FROM_ROM:
						CALL	LOAD_DOS_FROM_ROM
						JB		INFINITY


; Stack Top is YSDOS Segment
YSDOS_LOADED:
						MOV		SI,MSG_DOS_LOADED
						CALL	TEXT_MESSAGE


						; INPUT to YSDOS.SYS
						;    DX     ENDMEM 0C000H in TOWNS because always TOWNS has more than 640KB
						;    DS:SI  DEVHEAD

						MOV		DX,0C000h
						LDS		SI,CS:[CONDEV_PTR]

						PUSH	WORD CS:[DOSSEG]
						PUSH	WORD 0
						MOV		BP,SP

						MOV		DI,0
						MOV		FS,DI
						MOV		EDI,FS:[020H*4]
						PUSH	EDI

						CALL	FAR [BP]

						; OUTPUT from YSDOS.SYS
						;    ES:DI  Pointer to SYSVARS

						MOV		CS:[SYSVARS_PTR],DI
						MOV		CS:[SYSVARS_PTR+2],ES

						MOV		BX,DI
						MOV		DX,TSUGARUIO_VM_HOST_IF_CMD_STATUS
						MOV		AL,TOWNS_VMIF_CMD_NOTIFY_DOSLOL
						OUT		DX,AL


						MOV		SI,MSG_DOSINIT_PASSED
						CALL	TEXT_MESSAGE


						XOR		AX,AX
						MOV		FS,AX
						POP		EAX
						MOV		FS:[020H*4],EAX

						CALL	CREATE_CDS

						; Save Temporary PDB to a safe location.

						MOV		AH,48h	; ALLOC MEMORY
						MOV		BX,0FFFFh
						INT		21H

						; BX is largest available blocks.

						PUSH	BX

						MOV		AH,48h	; ALLOC MEMORY
						INT		21H

						POP		BX
						PUSH	AX	; Save largest memory chunk

						; AX is the largest memory chunk.

						MOV		ES,AX
						SUB		BX,11H
						MOV		AH,4Ah	; RESIZE MEMORY
						INT 	21H

						MOV		AH,48H	; ALLOC MEMORY
						MOV		BX,10H
						INT		21H

						; AX is 100h bytes memory chunk

						POP		ES	; ES is the largest memory chunk.
						PUSH	AX	; AX is the last 100h bytes before 0C0000h

						MOV		AH,49H	; FREE MEMORY
						INT		21H

						; Must have 100h byte secure memory block at the end of the DOS memory.

						MOV		AH,51H
						INT		21H

						; BX is PSP

						MOV		DS,BX
						XOR		SI,SI

						POP		ES
						PUSH	ES

						XOR		DI,DI

						CLD
						MOV		CX,128
						REP		MOVSW
						MOV		ES:[0036H],ES	; Far Pointer to File Table.

						MOV		BX,ES
						MOV		AH,50H	; SetPSP
						INT		21H


						MOV		DL,CS:[BOOT_DEVICE]
						CMP		DL,BOOTDEV_FD
						JE		BOOTDRV_ALREADY_SET
						CMP		DL,BOOTDEV_CD
						JE		BOOTDRV_ALREADY_SET
						CMP		DL,BOOTDEV_SCSICD
						JE		BOOTDRV_ALREADY_SET

						CALL	FIND_BOOT_DRIVE
						MOV		CS:[BOOT_DRIVE],AL
BOOTDRV_ALREADY_SET:
						; Postpone set current drive until installation of MSCDEX




						; Towns OS's IO.SYS seems to close file handle 0,1,2,3,4 (STDIN,STDOUT,STDERR,PRN,AUX), and then reopen CON, duplicate twice, and then reopen PRN, and AUX.
						; Why?  I don't know.
						MOV		BX,0
CLOSE_DEFAULT_FILE_LOOP:
						MOV		AH,3EH
						INT		21H
						INC		BX
						CMP		BX,5
						JBE		CLOSE_DEFAULT_FILE_LOOP

						MOV 	AX,3D02H	; OPEN, Mode=02
						MOV		DX,DEFAULT_CONDEV_NAME
						PUSH	CS
						POP		DS
						INT		21H		; Will be assigned to file handle 0 (STDIN)

						MOV		BX,AX
						MOV		AH,45H
						INT		21H		; Will be assigned to file handle 1 (STDOUT)
						MOV		AH,45H
						INT		21H		; Will be assigned to file handle 2 (STDERR)

						MOV		AL,CS:[BOOT_DRIVE]
						ADD		AL,'A'
						MOV		CS:[DEFAULT_COMSPEC],AL
						MOV		CS:[COMMANDCOM_PARAMETER+1],AL

						MOV		CS:[COMMANDCOM_PARAM_SEG],CS

						POP		ES
						MOV		AH,49H	; FREE MEMORY
						INT		21H


						MOV		SI,MSG_INSTALLING_MSCDEX
						CALL	TEXT_MESSAGE


						CALL	INSTALL_MSCDEX


						MOV		SI,MSG_MSCDEX_INSTALLED
						CALL	TEXT_MESSAGE


						MOV		DL,CS:[BOOT_DRIVE]
						MOV		AH,0Eh
						INT		21H


						MOV		SI,MSG_DO_CONFIG_SYS
						CALL	TEXT_MESSAGE


						CALL	DO_CONFIG_SYS

						CALL	CREATE_ADDITIONAL_SFT	; Make sure to do it after the preliminary PSP is copied.
						CALL	CREATE_ADDITIONAL_BUFFERS


						MOV		SI,MSG_START_YAMAND_COM
						CALL	TEXT_MESSAGE



						CALL	FLUSH_KEY_BUFFER	; For some reason real TOWNS gives 'k'.



						PUSH	CS
						POP		DS

						; CS=DS
						MOV		AX,4B00H	; EXEC
						MOV		DX,DEFAULT_COMSPEC
						PUSH	CS
						POP		ES
						MOV		BX,COMMANDCOM_PARAMBLOCK
						INT		21H

						CMP		BYTE CS:[COMMANDCOM_PARAMETER+2],':' ; If the parameter starts with like "C:\"
						JNE		COMMANDCOM_PARAM_DOES_NOT_START_WITH_PATH
						MOV		BYTE CS:[COMMANDCOM_PARAMETER+1],'C'
COMMANDCOM_PARAM_DOES_NOT_START_WITH_PATH:

						MOV		AX,4B00H	; EXEC
						PUSH	CS
						POP		DS
						MOV		DX,C_COMMAND_COM
						PUSH	CS
						POP		ES
						MOV		BX,COMMANDCOM_PARAMBLOCK
						INT		21H

HALT_FOREVER:
						HLT
						JMP		HALT_FOREVER


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Input SI: Message pointer
TEXT_MESSAGE:
						PUSH	DS
						PUSH	AX
						PUSH	BX
						PUSH	CX
						PUSH	DX

						PUSH	CS
						POP		DS
						MOV		AX,CS:[TEXT_POS]
						CALL	GRAPH_LOCATE
						CALL	GRAPH_PRINT_TALL
						INC		BYTE CS:[TEXT_Y]

						POP		DX
						POP		CX
						POP		BX
						POP		AX
						POP		DS
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


INSTALL_SCSI_CD_FAILED:
						MOV		SI,MSG_INSTALL_SCSI_CD_FAILED
						CALL	TEXT_MESSAGE
						JMP		INSTALL_SCSI_CD_FAILED


DISKBIOS_ERROR:
						PUSH	CX
						MOV		SI,MSG_ERROR_AX
						CALL	AX_TO_ASCII_CS_SI

						POP		AX
						MOV		SI,MSG_ERROR_CX
						CALL	AX_TO_ASCII_CS_SI

						MOV		SI,MSG_ERROR_AX_CX
						CALL	TEXT_MESSAGE

						JMP		INFINITY



AX_TO_ASCII_CS_SI:
						PUSH	CX

						SHLD	CX,AX,4
						CALL	CL_4BITS_TO_HEX
						MOV		CS:[SI],CL

						SHLD	CX,AX,8
						CALL	CL_4BITS_TO_HEX
						MOV		CS:[SI+1],CL

						SHLD	CX,AX,12
						CALL	CL_4BITS_TO_HEX
						MOV		CS:[SI+2],CL

						SHLD	CX,AX,16
						CALL	CL_4BITS_TO_HEX
						MOV		CS:[SI+3],CL

						POP		CX

						RET

CL_4BITS_TO_HEX:
						AND		CL,0FH
						CMP		CL,10
						JAE		FOUBITS_TO_HEX_ALPHABETS
						ADD		CL,'0'
						RET
FOUBITS_TO_HEX_ALPHABETS:
						ADD		CL,'A'-10
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


						ALIGN	32
DEFAULT_COMSPEC			DB		"A:\YAMAND.COM",0	; 14 bytes
						DB		18 dup(0)

						ALIGN	32
C_COMMAND_COM:			DB		"C:\COMMAND.COM",0	; 15 bytes
						DB		17 dup(0)

						ALIGN	32
COMMANDCOM_PARAMETER	DB		" A:\ /P",0

						ALIGN	32
DEFAULT_CONDEV_NAME		DB		"CON",0

COMMANDCOM_PARAMBLOCK	DW		0	; ENVSEG to copy from
						DW		COMMANDCOM_PARAMETER	; Command Tail OFFSET
COMMANDCOM_PARAM_SEG	DW		IOSYS_CS				; Command Tail SEG
						DW		FCB_WAS_A_BAD_IDEA		; First FCB to be copied
						DW		DOSLOADER_EXE_SEG
						DW		FCB_WAS_A_BAD_IDEA		; Second FCB to be copied
						DW		DOSLOADER_EXE_SEG

FCB_WAS_A_BAD_IDEA:		DB		16 dup (0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Input AX    = number of pages to push
;       FS:BX = DOS SYSVARS
;
; Preserves FS,BX  No guarantee for other regs
; Destroys DS,ES,SI,DI,DX for sure.
PUSH_MCB:
						MOV		SI,FS:[BX-2]
						MOV		DS,SI
						ADD		SI,AX
						MOV		ES,SI

						XOR		SI,SI
						XOR		DI,DI
						CLD
						MOVSD
						MOVSD
						MOVSD
						MOVSD

						SUB		ES:[MCB_BLOCK_SIZE],AX
						ADD		FS:[BX-2],AX

						RET


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


CREATE_CDS:
						LDS		DI,CS:[CDS_PTR]

						LGS		BX,CS:[SYSVARS_PTR]

						LFS		SI,GS:[BX+SYSVARS_FIRST_DPB]

						XOR		CL,CL
						MOV		CH,GS:[BX+SYSVARS_NUM_DPB]
CREATE_CDS_LOOP:
						MOV		EAX,05C3A41h	; 41H='A'  3A=':'  5C='\'
						ADD		AL,CL
						MOV		[DI+CDS_CURDIR],EAX
						MOV		WORD [DI+CDS_CURDIR_CLUSTER],0xFFFF
						MOV		WORD [DI+CDS_CURDIR_ROOTLEN],2

						CMP		CL,CH
						JGE		CREATE_CDS_NO_MORE_DPB

						MOV		WORD [DI+CDS_DRIVE_TYPE],CDS_TYPE_VALID
						MOV		[DI+CDS_DRIVE_PARAM_BLOCK],SI
						MOV		[DI+CDS_DRIVE_PARAM_BLOCK+2],FS
						LFS		SI,FS:[SI+DPB_PTR_TO_NEXT_DPB]

CREATE_CDS_NO_MORE_DPB:
						ADD		DI,CURRENT_DIR_STRUCT_size
						INC		CL
						CMP		CL,MAX_NUM_CDS
						JB		CREATE_CDS_LOOP

						MOV		AX,CS:[CDS_PTR]
						MOV		WORD GS:[BX+SYSVARS_FIRST_CDS],AX
						MOV		WORD GS:[BX+SYSVARS_FIRST_CDS+2],DS
						MOV		BYTE GS:[BX+SYSVARS_NUM_CDS],MAX_NUM_CDS

						RET


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


CREATE_ADDITIONAL_SFT:
						; Push FIRST_MCB and make FCB there.
						LFS		BX,CS:[SYSVARS_PTR]	; FS:BX is SYSVARS
						MOV		ES,FS:[BX-2]		; ES is First MCB

						MOVZX	AX,BYTE CS:[CONFIG_SYS_FILES]
						MOV		DX,SFT_ENTRY_SIZE
						MUL		DX
						ADD		AX,SFT_HEADER_size+15
						SHR		AX,4

						PUSH	ES
						PUSH	AX
						CALL	PUSH_MCB
						POP		AX
						POP		ES

						SHL		AX,4	; DX is the number of bytes aligned to the page border.

						XOR		DI,DI
						MOV		CX,AX
						XOR		AX,AX
						CLD
						REP		STOSB

						MOV		DWORD ES:[0],0FFFFFFFFh
						MOVZX	AX,BYTE CS:[CONFIG_SYS_FILES]
						MOV		ES:[4],AX

						XOR		AX,AX
						MOV		FS:[BX+SYSVARS_SFT],AX
						MOV		FS:[BX+SYSVARS_SFT+2],ES


						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CREATE_ADDITIONAL_BUFFERS:
						; Push FIRST_MCB and make FCB there.
						LFS		BX,CS:[SYSVARS_PTR]	; FS:BX is SYSVARS
						MOV		ES,FS:[BX-2]		; ES is First MCB

						MOVZX	EAX,BYTE CS:[CONFIG_SYS_BUFFERS]
						MOV		EDX,2048+16
						MUL		EDX
						SHR		EAX,4

						PUSH	ES
						PUSH	AX
						CALL	PUSH_MCB
						POP		AX
						POP		ES

						XOR		DI,DI
						MOVZX	CX,BYTE CS:[CONFIG_SYS_BUFFERS]

CREATE_ADDITIONAL_BUFFERS_LOOP:
						MOV		AX,77D3H
						INT		21H
						ADD		DI,2048+16

						LOOP	CREATE_ADDITIONAL_BUFFERS_LOOP

						RET


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MSCDEX_FILENAME			DB		"C:\MSCDEX.EXE",0
MSCDEX_PARAMETER		DB		" /L:Q /D:TOWNS_CD /M:8",0

MSCDEX_PARAMBLOCK		DW		0	; ENVSEG to copy from
						DW		MSCDEX_PARAMETER		; Command Tail OFFSET
MSCDEX_PARAM_SEG		DW		IOSYS_CS				; Command Tail SEG
						DW		FCB_WAS_A_BAD_IDEA		; First FCB to be copied
						DW		DOSLOADER_EXE_SEG
						DW		FCB_WAS_A_BAD_IDEA		; Second FCB to be copied
						DW		DOSLOADER_EXE_SEG

INSTALL_MSCDEX:
						MOV		AX,4B00H	; EXEC
						PUSH	CS
						POP		DS
						MOV		DX,MSCDEX_FILENAME
						PUSH	CS
						POP		ES
						MOV		BX,MSCDEX_PARAMBLOCK
						MOV		CS:[MSCDEX_PARAM_SEG],CS
						INT		21H
						JC		INSTALL_MSCDEX_FAIL

						; If successful, update MCB so that drivers won't overwrite MSCDEX.

						LES		DI,CS:[SYSVARS_PTR]
						MOV		DS,ES:[DI-2]		; First MCB

						CMP		BYTE [0],4DH	; Has a chain.
						JNE		INSTALL_MSCDEX_FAIL

						MOV		AX,DS
						ADD		AX,[3]
						INC		AX
						MOV		ES:[DI-2],AX

INSTALL_MSCDEX_FAIL:
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CONFIGSYS_FILENAME		DB		"A:\CONFIG.SYS",0
CONFIGSYS_LENGTH		DW		0

KEYWORD_BUFFERS			DB		"BUFFERS"
KEYWORD_BUFFERS_LENGTH	EQU		7
KEYWORD_SHELL			DB		"SHELL"
KEYWORD_SHELL_LENGTH	EQU		5
KEYWORD_DEVICE			DB		"DEVICE"
KEYWORD_DEVICE_LENGTH	EQU		6
KEYWORD_FILES			DB		"FILES"
KEYWORD_FILES_LENGTH	EQU		5

DEVICE_LOAD_POINT		DW		0
						DW		0

DO_CONFIG_SYS:
						CALL	LOAD_CONFIG_SYS
						JC		CONFIG_SYS_NOT_FOUND


						LDS		SI,CS:[SYSVARS_PTR]
						MOV		BX,DS:[SI-2]	; First MCB
						INC		BX				; Protect the current MCB.  I waste 16 bytes.
						MOV		CS:[DEVICE_LOAD_POINT],BX
						MOV		CS:[DEVICE_LOAD_POINT+2],BX

						MOV		SI,CONFIGSYS_SEG
						MOV		DS,SI
						XOR		SI,SI

						PUSH	CS
						POP		ES
DO_CONFIG_SYS_LOOP:
						; DS:SI is the CONFIG.SYS pointer.
						CALL	CONFIG_SYS_COUNT_LINE_LENGTH
						; BX is the length of the line

						PUSH	BX

						MOV		BYTE [SI+BX],0	; Terminate the string.
						OR		BX,BX
						JE		DO_CONFIG_SYS_NEXT

						CALL	CONFIGSYS_CAPITALIZE_BEFORE_EQUAL

						PUSH	SI
						MOV		DI,KEYWORD_BUFFERS
						MOV		CX,KEYWORD_BUFFERS_LENGTH
						REPE	CMPSB
						POP		SI
						JNE		DO_CONFIG_NOT_BUFFERS
						CALL	DO_CONFIG_BUFFERS
						JMP		DO_CONFIG_SYS_NEXT

DO_CONFIG_NOT_BUFFERS:
						PUSH	SI
						MOV		DI,KEYWORD_SHELL
						MOV		CX,KEYWORD_SHELL_LENGTH
						REPE	CMPSB
						POP		SI
						JNE		DO_CONFIG_NOT_SHELL
						CALL	DO_CONFIG_SHELL
						JMP		DO_CONFIG_SYS_NEXT

DO_CONFIG_NOT_SHELL:
						PUSH	SI
						MOV		DI,KEYWORD_DEVICE
						MOV		CX,KEYWORD_DEVICE_LENGTH
						REPE	CMPSB
						POP		SI
						JNE		DO_CONFIG_NOT_DEVICE
						CALL	DO_CONFIG_DEVICE
						JMP		DO_CONFIG_SYS_NEXT

DO_CONFIG_NOT_DEVICE:
						PUSH	SI
						MOV		DI,KEYWORD_FILES
						MOV		CX,KEYWORD_FILES_LENGTH
						REPE	CMPSB
						POP		SI
						JNE		DO_CONFIG_NOT_FILES
						CALL	DO_CONFIG_FILES
						JMP		DO_CONFIG_SYS_NEXT

DO_CONFIG_NOT_FILES:


DO_CONFIG_SYS_NEXT:
						POP		BX
						LEA		SI,[SI+BX+1]
						CMP		SI,CS:[CONFIGSYS_LENGTH]
						JB		DO_CONFIG_SYS_LOOP

DO_CONFIG_SYS_EXIT:
						LES		DI,CS:[ADDITIONAL_IO_BUF_PTR]
						MOV		AX,77D3H	; YSDOS extension.  Add Buffer
						INT		21H

						LFS		BX,CS:[SYSVARS_PTR]
						MOV		AX,CS:[DEVICE_LOAD_POINT]
						SUB		AX,FS:[BX-2]
						; Input AX    = number of pages to push
						;       FS:BX = DOS SYSVARS
						CALL	PUSH_MCB

CONFIG_SYS_NOT_FOUND:
						RET


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DO_CONFIG_SHELL:
						PUSH	DS
						PUSH	SI

						PUSH	CS
						POP		ES
						MOV		DI,DEFAULT_COMSPEC
						CLD

						CALL	CONFIG_SYS_SKIP_EQUAL
						CMP		BYTE [SI-1],'='
						JNE		DO_CONFIG_SHELL_EXIT

						XOR		CX,CX
DO_CONFIG_SHELL_COPY_CMD:
						LODSB
						CALL	AL_IS_SPACE_OR_TAB
						JE		DO_CONFIG_SHELL_COPY_CMD_DONE
						CALL	AL_IS_ZERO_CR_OR_LF
						JE		DO_CONFIG_SHELL_COPY_CMD_DONE
						STOSB
						INC		CX
						CMP		CX,31
						JB		DO_CONFIG_SHELL_COPY_CMD

DO_CONFIG_SHELL_COPY_CMD_DONE:
						MOV		BYTE ES:[DI],0

						CALL	AL_IS_SPACE_OR_TAB
						JNE		DO_CONFIG_SHELL_EXIT

						XOR		CX,CX

						MOV		AL,' '
						MOV		DI,COMMANDCOM_PARAMETER
						STOSB
DO_CONFIG_SHELL_COPY_PARAMETER:
						LODSB
						CALL	AL_IS_ZERO_CR_OR_LF
						JE		DO_CONFIG_SHELL_COPY_PARAMETER_DONE
						STOSB
						INC		CX
						CMP		CX,31
						JB		DO_CONFIG_SHELL_COPY_PARAMETER

DO_CONFIG_SHELL_COPY_PARAMETER_DONE:
						MOV		BYTE ES:[DI],0

DO_CONFIG_SHELL_EXIT:
						POP		SI
						POP		DS
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CONFIG_INIT_REQ			DB		17H			; +00H Length
						DB		0			; +01H Unit N/A for Init
						DB		0			; +02H Command=00 Init
CONFIG_INIT_STATUS		DW		0			; +03H Return Code
						DB		8 dup(0)	; +05H Not used for Init
CONFIG_INIT_UNITS		DB		0			; +0DH Number of units (Output)
CONFIG_INIT_END_RES		DD		0			; +0EH End of resident code (Output)
CONFIG_INIT_BPB_ARRAY:
CONFIG_INIT_CMDLINE		DD		0			; +12H Command Line (Input) -> BPB array pointer (Output)
CONFIG_INIT_FIRST_DRV	DB		0			; +16H First drive
						DW		0			; +17H Looks like DOS 4.0 uses this byte, just in case.


DO_CONFIG_DEVICE:
						PUSH	DS
						PUSH	SI

						MOV		AX,CS
						MOV		ES,AX	; ES=CS

						CALL	CONFIG_SYS_SKIP_EQUAL
						CMP		BYTE [SI-1],'='
						JNE		DO_CONFIG_DEVICE_EXIT

						CALL	CONFIG_SYS_SKIP_SPACE_AND_TAB

						; DS:SI points to the command line.
						MOV		DX,SI	; DS:DX points to the file name.

						CALL	CONFIG_SYS_SKIP_UNTIL_SPACE_AND_TAB

						XOR		CL,CL
						XCHG	CL,[SI]		; Make file-name a C-String (Terminate by \0)

						MOV		AX,4B03H ; LOAD Overlay
						MOV		BX,DEVICE_LOAD_POINT	; Pointer to the device load point and relocation factor
						INT		21H

						JB		DO_CONFIG_DEVICE_EXIT	; Load Error

						XCHG	CL,[SI]		; Recover space

						MOV		CS:[CONFIG_INIT_CMDLINE],SI
						MOV		CS:[CONFIG_INIT_CMDLINE+2],DS

						; FS points to the device driver.
						MOV		FS,CS:[DEVICE_LOAD_POINT]

						; ES is already CS
						MOV		BX,CONFIG_INIT_REQ
						MOV		BYTE CS:[CONFIG_INIT_UNITS],0
						MOV		BYTE CS:[CONFIG_INIT_FIRST_DRV],0
						MOV		CS:[CONFIG_INIT_END_RES],FS
						CALL	CALL_STRATEGY_AND_INTERRUPT

						CMP		WORD CS:[CONFIG_INIT_STATUS],0100h	; Status Code=Done
						JNE		DO_CONFIG_DEVICE_EXIT

						; Re-load FS just in case.
						MOV		FS,CS:[DEVICE_LOAD_POINT]

						MOV		BX,WORD CS:[CONFIG_INIT_END_RES]
						ADD		BX,15
						SHR		BX,4
						ADD		BX,WORD CS:[CONFIG_INIT_END_RES+2]
						AND		BX,BX
						JE		DO_CONFIG_DEVICE_EXIT

						MOV		CS:[DEVICE_LOAD_POINT],BX
						MOV		CS:[DEVICE_LOAD_POINT+2],BX

						; FS is pointing to the derive drive just loaded.
						; BX is the next load point.
						TEST	WORD FS:[SYSDEV_DEVFLAGS],8000H
						JNE		DO_CONFIG_DEVICE_EXIT

						; Do Block Dev.
						; TSUGARU_DEBUG

 						CMP		BYTE CS:[CONFIG_INIT_UNITS],0
						JE		DO_CONFIG_DEVICE_EXIT
 						LDS		SI,CS:[CONFIG_INIT_BPB_ARRAY]
						MOV		SI,DS:[SI]	; CONFIG_INIT_BPB_ARRAY is like a double-pointer.
 						MOV		ES,CS:[DEVICE_LOAD_POINT]
 						XOR		BP,BP
DO_CONFIG_BLOCKDEV_LOOP:
						MOV		AH,53H	; Make DPB
						INT		21H

						MOV		CL,CS:[CONFIG_INIT_FIRST_DRV]
						CALL	DO_CONFIG_FIND_AVAILABLE_CDS
						JB		DO_CONFIG_DEVICE_EXIT

						MOV		WORD ES:[BP+DPB_PTR_TO_DEV_DRIVER],0
						MOV		WORD ES:[BP+DPB_PTR_TO_DEV_DRIVER+2],FS
						MOV		CS:[CONFIG_INIT_FIRST_DRV],CL

						MOV		ES:[BP+DPB_DRIVE_CODE],CL
						MOV		WORD GS:[DI+CDS_DRIVE_TYPE],CDS_TYPE_VALID
						MOV		GS:[DI+CDS_DRIVE_PARAM_BLOCK],BP
						MOV		GS:[DI+CDS_DRIVE_PARAM_BLOCK+2],ES

						ADD		SI,BIOS_PARAMETER_BLOCK_size
						ADD		BP,DRIVE_PARAM_BLOCK_size

						DEC		BYTE CS:[CONFIG_INIT_UNITS]
						JNE		DO_CONFIG_BLOCKDEV_LOOP

						ADD		BP,15
						SHR		BP,4
						MOV		BX,ES
						ADD		BX,BP

						MOV		CS:[DEVICE_LOAD_POINT],BX
						MOV		CS:[DEVICE_LOAD_POINT+2],BX

DO_CONFIG_DEVICE_EXIT:
						POP		SI
						POP		DS
						RET


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Input		FS   =Device Driver
;			ES:BX=Request Header
CALL_STRATEGY_AND_INTERRUPT:
						PUSH	FS
						PUSH	WORD FS:[6]

						MOV		SI,SP
						CALL	FAR [SS:SI]

						ADD		SP,2
						PUSH	WORD FS:[8]
						CALL	FAR [SS:SI]

						ADD		SP,4
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Input:  CL=Unit number to start search from
; Output: CL=Unit number available
;         GS:DI=CDS
;         CF=0 Found one available.
;         CF=1 Not found.
;         DS,SI,ES,BP preserved.
DO_CONFIG_FIND_AVAILABLE_CDS:
						PUSH	DS
						PUSH	SI
						PUSH	ES
						PUSH	BP

						MOV		AH,19H		; Get Current Drive
						INT		21H
						MOV		AH,0EH		; Set Current Drive
						INT		21H
						; Now AL is the number of potential drive letters.

						MOV		CH,AL

						CMP		CL,CH
						JAE		DO_CONFIG_NO_AVAILABLE_CDS

						MOV		AH,52H		; Get List of Lists
						INT		21H
						LGS		DI,ES:[BX+SYSVARS_FIRST_CDS]

						MOV		AL,CL
						MOV		AH,CURRENT_DIR_STRUCT_size
						MUL		AH

						ADD		DI,AX
DO_CONFIG_FIND_AVAIL_CDS_LOOP:
						CMP		WORD GS:[DI+CDS_DRIVE_TYPE],0
						JE		DO_CONFIG_FOUND_AVAIL_CDS
						ADD		DI,CURRENT_DIR_STRUCT_size
						INC		CL
						CMP		CL,CH
						JB		DO_CONFIG_FIND_AVAIL_CDS_LOOP
						JMP		DO_CONFIG_NO_AVAILABLE_CDS

DO_CONFIG_FOUND_AVAIL_CDS:
						CLC

DO_CONFIG_FIND_AVAIL_CDS_EXIT:
						POP		BP
						POP		ES
						POP		SI
						POP		DS
						RET

DO_CONFIG_NO_AVAILABLE_CDS:
						STC
						JMP		DO_CONFIG_FIND_AVAIL_CDS_EXIT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DO_CONFIG_FILES:
						PUSH	DS
						PUSH	SI

						CALL	CONFIG_SYS_SKIP_EQUAL
						CMP		BYTE [SI-1],'='
						JNE		DO_CONFIG_FILES_RET

						CALL	CONFIG_SYS_SKIP_SPACE_AND_TAB

						CALL	ATOI8

						CMP		AL,32
						JB		DO_CONFIG_FILES_UPPERBOUND
						MOV		AL,32

DO_CONFIG_FILES_UPPERBOUND:
						MOV		CS:[CONFIG_SYS_FILES],AL

DO_CONFIG_FILES_RET:
						POP		SI
						POP		DS
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DO_CONFIG_BUFFERS:
						PUSH	DS
						PUSH	SI

						CALL	CONFIG_SYS_SKIP_EQUAL
						CMP		BYTE [SI-1],'='
						JNE		DO_CONFIG_FILES_RET

						CALL	CONFIG_SYS_SKIP_SPACE_AND_TAB

						CALL	ATOI8

						CMP		AL,24
						JB		DO_CONFIG_BUFFERS_UPPERBOUND
						MOV		AL,24

DO_CONFIG_BUFFERS_UPPERBOUND:
						MOV		CS:[CONFIG_SYS_BUFFERS],AL

DO_CONFIG_BUFFERS_RET:
						POP		SI
						POP		DS
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

GET_UINT8_AFTER_EQUAL:
						LODSB
						CMP		AL,9	; TAB
						JE		GET_UINT8_AFTER_EQUAL
						CMP		AL,' '
						JE		GET_UINT8_AFTER_EQUAL

						CMP		AL,'='
						JNE		GET_UINT8_AFTER_EQUAL_ERROR

						; Found Equal
GET_UINT8_SKIP_SPACE_AFTER_EQ:
						LODSB
						CMP		AL,9	; TAB
						JE		GET_UINT8_SKIP_SPACE_AFTER_EQ
						CMP		AL,' '
						JE		GET_UINT8_SKIP_SPACE_AFTER_EQ

						CALL	ATOI8
						CLC
						RET

GET_UINT8_AFTER_EQUAL_ERROR:
						STC
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ATOI8:
						MOV		AH,0

ATOI8_LOOP:
						MOV		AL,DS:[SI]
						SUB		AL,'0'
						CMP		AL,9
						JA		ATOI8_EXIT

						MOV		AL,AH
						SHL		AH,3	; times 8
						ADD		AH,AL
						ADD		AH,AL	; times 10

						LODSB
						SUB		AL,'0'
						ADD		AH,AL
						JMP		ATOI8_LOOP

ATOI8_EXIT:
						MOV		AL,AH
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Input DS:SI=Pointer to the line
; Output BX=Line Length
CONFIG_SYS_COUNT_LINE_LENGTH:
						XOR		BX,BX

CONFIG_SYS_COUNT_LINE_LENGTH_LOOP:
						MOV		AL,[SI+BX]
						CMP		AL,0Dh
						JE		CONFIG_SYS_COUNT_LINE_LENGTH_EXIT
						CMP		AL,0Ah
						JE		CONFIG_SYS_COUNT_LINE_LENGTH_EXIT
						OR		AL,AL
						JE		CONFIG_SYS_COUNT_LINE_LENGTH_EXIT
						INC		BX
						JMP		CONFIG_SYS_COUNT_LINE_LENGTH_LOOP

CONFIG_SYS_COUNT_LINE_LENGTH_EXIT:
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Input DS:SI=Pointer to the line
; Output DS:SI=Pointer to after the first '='.  Or, can be end of the command line.
;        AL=Destroyed
CONFIG_SYS_SKIP_EQUAL:
						MOV		AL,[SI]
						CALL	AL_IS_ZERO_CR_OR_LF
						JE		CONFIG_SYS_SKIP_EQUAL_EXIT

						INC		SI
						CMP		AL,'='
						JNE		CONFIG_SYS_SKIP_EQUAL

CONFIG_SYS_SKIP_EQUAL_EXIT:
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Input DS:SI=Pointer to a string.
; Output DS:SI=Pointer to after skipping SPACEs and TABs.  Or, can be end of the command line.
;        AL=Destroyed
CONFIG_SYS_SKIP_SPACE_AND_TAB:
						MOV		AL,[SI]
						CALL	AL_IS_SPACE_OR_TAB
						JNE		CONFIG_SYS_SKIP_SPACE_AND_TAB_EXIT

						INC		SI
						JMP		CONFIG_SYS_SKIP_SPACE_AND_TAB

CONFIG_SYS_SKIP_SPACE_AND_TAB_EXIT:
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Input DS:SI=Pointer to a string.
; Output DS:SI=Pointer to first ' '.  Or, can be end of the command line.
;        AL=Destroyed
CONFIG_SYS_SKIP_UNTIL_SPACE_AND_TAB:
						MOV		AL,[SI]
						CALL	AL_IS_SPACE_OR_TAB
						JE		CONFIG_SYS_SKIP_UNTIL_SPACE_AND_TAB_EXIT

						CALL	AL_IS_ZERO_CR_OR_LF
						JE		CONFIG_SYS_SKIP_UNTIL_SPACE_AND_TAB_EXIT

						INC		SI
						JMP		CONFIG_SYS_SKIP_UNTIL_SPACE_AND_TAB

CONFIG_SYS_SKIP_UNTIL_SPACE_AND_TAB_EXIT:
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Input  AL=ASCII Code
; Output ZF is set if AL is space or tab.
AL_IS_SPACE_OR_TAB:
						CMP		AL,' '
						JE		AL_IS_SPACE_OR_TAB_EXIT
						CMP		AL,TAB

AL_IS_SPACE_OR_TAB_EXIT:
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Input  AL=ASCII Code
; Output ZF is set if AL is space or tab.
AL_IS_ZERO_CR_OR_LF:
						OR		AL,AL
						JE		AL_IS_ZERO_CR_OR_LF_EXIT
						CMP		AL,0DH
						JE		AL_IS_ZERO_CR_OR_LF_EXIT
						CMP		AL,0AH
						JE		AL_IS_ZERO_CR_OR_LF_EXIT

AL_IS_ZERO_CR_OR_LF_EXIT:
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Input  DS:SI=Pointer to the line,  BX=Line Length
; CX destroyed.
CONFIGSYS_CAPITALIZE_BEFORE_EQUAL:
						MOV		CX,BX
						XOR		BX,BX

CONFIGSYS_CAPITALIZE_BEFORE_EQUAL_LOOP:
						MOV		AL,DS:[SI+BX]
						CMP		AL,'='
						JE		CONFIGSYS_CAPITALIZE_BEFORE_EQUAL_EXIT

						AND		AL,0DFh
						MOV		DS:[SI+BX],AL

						INC		BX
						CMP		BX,CX
						JB		CONFIGSYS_CAPITALIZE_BEFORE_EQUAL_LOOP

CONFIGSYS_CAPITALIZE_BEFORE_EQUAL_EXIT:
						MOV		BX,CX
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


LOAD_CONFIG_SYS:
						MOV		DX,CONFIGSYS_SEG
						MOV		ES,DX
						CLD
						MOV		CX,CONFIGSYS_SIZE_LIMIT
						XOR		AX,AX
						REP		STOSB

						MOV		AL,CS:[BOOT_DRIVE]
						ADD		AL,'A'
						MOV		CS:[CONFIGSYS_FILENAME],AL

						MOV		AX,3D00h	; FOPEN Normal Mode
						PUSH	CS
						POP		DS
						MOV		DX,CONFIGSYS_FILENAME
						INT		21H
						JB		LOAD_CONFIG_SYS_EXIT

						MOV		BX,AX

						; BX is file handle

						MOV		AH,3FH	; FREAD
						MOV		CX,CONFIGSYS_SIZE_LIMIT
						MOV		DX,CONFIGSYS_SEG
						MOV		DS,DX
						XOR		DX,DX
						INT		21H
						JB		LOAD_CONFIG_SYS_EXIT

						; AX is the number of bytes actually read.
						MOV		CS:[CONFIGSYS_LENGTH],AX

						; BX is still the file handle

						MOV		AH,3EH	; FCLOSE
						INT		21H

LOAD_CONFIG_SYS_EXIT:
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

INFINITY				JMP		INFINITY

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LOAD_DOS_FROM_HD:
						; BH is SCSI ID, it is backed up in CS:[BOOT_DEVICE]

						; First get partition table.
						MOV		AL,BH
						AND		AL,0FH
						OR		AL,DISKBIOS_SCSI_0
						MOV		CS:[DISKBIOS_BOOT_DEVICE],AL

						MOV		AH,DISKBIOS_CMD_03H_RESTORE
						INT		93H

						MOV		AH,DISKBIOS_CMD_05H_READ_SECTOR
						MOV		AL,CS:[DISKBIOS_BOOT_DEVICE]
						MOV		CX,0		; LBA High
						MOV		DX,0001h	; LBA Low
						MOV		BX,1		; 1 sector
						MOV		DI,BOOTSECT_SEG
						MOV		DS,DI
						XOR		DI,DI
						INT		93H
						JB		INFINITY

						MOV		EDI,DS:[PARTITION_TABLE_FIRST_PARTITION_LBA]
						MOV		SI,PARTITION_TABLE_FIRST_PARTITION

						MOVZX	CX,BYTE CS:[BOOT_PARTITION]
						JCXZ	LOAD_FROM_HD_PARTITION_LOOP_EXIT
LOAD_FROM_HD_PARTITION_LOOP:
						ADD		EDI,DS:[SI+PARTITION_TABLE_NUM_SECTORS]
						ADD		SI,PARTITION_ENTRY_SIZE
						LOOP	LOAD_FROM_HD_PARTITION_LOOP

LOAD_FROM_HD_PARTITION_LOOP_EXIT:
						;	EDI is the first sector of the partition.
						MOV		CS:[BOOT_PARTITION_LBA0],EDI

						MOV		AH,DISKBIOS_CMD_05H_READ_SECTOR
						MOV		AL,CS:[DISKBIOS_BOOT_DEVICE]
						SHRD	ECX,EDI,16
						MOV		DX,DI
						MOV		BX,1		; 1 sector
						MOV		DI,BOOTSECT_SEG
						MOV		DS,DI
						MOV		FS,DI		; Prepare to use as BPB
						XOR		DI,DI
						INT		93H
						JB		LOAD_DOS_FROM_HD_ERR

						CMP		DWORD DS:[DI],344C5049H	; 'IPL4'
						JNE		LOAD_DOS_FROM_HD_ERR



						MOV		DI,BPB_POS_IN_IPL	; FS:DI is BPB

						CALL	BPB_CALC_ROOTDIR_SECT_CT	; In DOSUTIL.NSM  AX is # root-dir sectors, DX destroyed
						PUSH	AX	; Save ROOTDIR Logical sector count
						CALL	BPB_LOGICAL_SECTOR_TO_HD_LBA
						MOV		BX,AX

						; BX is the number of sectors of the root dir.

						CALL	BPB_CALC_ROOTDIR_LBA		; In DOSUTIL.NSM

						PUSH	AX	; Save ROOTDIR Logical Sector

						CALL	BPB_LOGICAL_SECTOR_TO_HD_LBA
						ADD		EAX,CS:[BOOT_PARTITION_LBA0]

						SHLD	ECX,EAX,16	; CX:AX is LBA (physical sector)
						MOV		DX,AX

						MOV		AH,DISKBIOS_CMD_05H_READ_SECTOR
						MOV		AL,CS:[DISKBIOS_BOOT_DEVICE]
						MOV		DI,ROOTDIR_OFFSET
						INT		93H
						JB		HDBOOT_YSDOS_NOT_FOUND



						; Input
						;   DS:SI	Directory
						;   ES:DI	File name in DOS 8+3 format
						;   DX		Number of files in the directory (including unused directory)
						; Output
						;   CX      Destroyed
						;   DX		0
						;   DF      Clear
						;   CF=0    DS:SI=Found directory entry
						;   CF=1    Not found  SI points to the end of the directory

						; DS is already set.
						MOV		SI,ROOTDIR_OFFSET
						PUSH	CS
						POP		ES
						MOV		DI,YSDOS_SYS_FILENAME
						MOV		DX,FS:[BPB_POS_IN_IPL+BPB_NUM_ROOT_DIR_ENT]
						CALL	SEARCH_DIRECTORY
						JB		HDBOOT_YSDOS_NOT_FOUND

						; Need to know
						;   Where YSDOS.SYS started (LBA)
						;   How many sectors.

						MOV		DI,BPB_POS_IN_IPL

						MOV		EAX,[SI+DIRENT_FILE_SIZE]
						MOVZX	ECX,WORD [DI+BPB_BYTES_PER_SECTOR]

						ADD		EAX,ECX	; For rounding up (+bytesPerSector-1)
						DEC		EAX

						XOR		EDX,EDX
						DIV		ECX
						CALL	BPB_LOGICAL_SECTOR_TO_HD_LBA

						MOVZX	EBX,AX

						; BX is number of sectors.

						MOV		AX,[SI+DIRENT_FIRST_CLUSTER]

						CALL	BPB_CLUSTER_TO_SECT_CT
						POP		DX	; DX will be overwritten by BPB_LBA_TO_CYLINDER_HEAD_SECTOR anyway
						ADD		AX,DX
						POP		DX
						ADD		AX,DX
						CALL	BPB_LOGICAL_SECTOR_TO_HD_LBA
						ADD		EAX,CS:[BOOT_PARTITION_LBA0]

						SHLD	ECX,EAX,16	; CX:AX is LBA (physical sector)
						MOV		DX,AX

						MOV		DS,CS:[DOSSEG]	; YSDOS Loading Point
						XOR		DI,DI
						MOV		AH,DISKBIOS_CMD_05H_READ_SECTOR
						MOV		AL,CS:[DISKBIOS_BOOT_DEVICE]

						INT		93H

						; CF set by INT 93H

						RET

HDBOOT_YSDOS_NOT_FOUND:
						ADD		SP,4
LOAD_DOS_FROM_HD_ERR:
						STC
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LOAD_DOS_FROM_CD:
						MOV		BYTE CS:[BOOT_DRIVE],'Q'-'A'

						; Input
						;   AL=BIOS Device ID (C0H for Internal CD,  B?H for SCSI CD)
						;   DS:DI=4KB Sector Buffer
						;   ES:SI=File Name, zero-terminated
						; Output
						;   Searches only the root directory.
						;   Registers will be destroyed.
						;   CF=0  EBX  LBA
						;         ECX  File Size
						;   CF=1  AH=00 File Not Found
						;         AH=80H Hard Error CX=Error Detail
						;         AH=Non-Zero  BIOS Error

						MOV		AL,DISKBIOS_CD

						MOV		DI,BOOTSECT_SEG	; Can be used for finding LBA for YSDOS.SYS
						MOV		DS,DI
						XOR		DI,DI

						PUSH	CS
						POP		ES
						MOV		SI,YSDOS_SYS_FILENAME_CSTR

						CALL	ISO9660_FIND_LBA
						JC		LOAD_DOS_FROM_CD_EXIT


						XCHG	EBX,ECX
						ADD		EBX,7FFH
						SHR		EBX,11

						; EBX is Number of sectors

						MOV		EDX,ECX
						SHLD	ECX,EDX,16

						; CX|DX is the sector

						MOV		AL,DISKBIOS_CD
						MOV		AH,DISKBIOS_CMD_05H_READ_SECTOR

						MOV		DS,CS:[DOSSEG]	; YSDOS Loading Point
						XOR		DI,DI

						INT		93H

LOAD_DOS_FROM_CD_EXIT:
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LOAD_DOS_FROM_FD:
						MOV		AL,BH
						AND		AL,0FH
						MOV		CS:[BOOT_DRIVE],AL	; A or B.  If the 3rd FD, forget about it....

						MOV		SI,MSG_RESTORE
						CALL	TEXT_MESSAGE

						OR		AL,DISKBIOS_FDD_0
						MOV		CS:[DISKBIOS_BOOT_DEVICE],AL

						MOV		AH,DISKBIOS_CMD_03H_RESTORE
						INT		93H


						MOV		SI,MSG_READ_BPB
						CALL	TEXT_MESSAGE


						; Read IPL Sector to get BPB
						MOV		AH,DISKBIOS_CMD_05H_READ_SECTOR
						MOV		AL,CS:[DISKBIOS_BOOT_DEVICE]
						MOV		CX,0		; Track 0
						MOV		DX,0001h	; Head 0 Sector 1
						MOV		BX,1		; 1 sector
						MOV		DI,BOOTSECT_SEG
						MOV		DS,DI
						MOV		FS,DI	; Prep to use BPB
						XOR		DI,DI
						INT		93H
						JB		DISKBIOS_ERROR



						MOV		DI,BPB_POS_IN_IPL

						CALL	BPB_CALC_ROOTDIR_SECT_CT	; In DOSUTIL.NSM  AX is # root-dir sectors, DX destroyed
						MOV		BX,AX
						PUSH	AX	; Save ROOTDIR sector count

						; BX is the number of sectors of the root dir.

						CALL	BPB_CALC_ROOTDIR_LBA		; In DOSUTIL.NSM

						PUSH	AX	; Save ROOTDIR LBA

						CALL	BPB_LBA_TO_CYLINDER_HEAD_SECTOR


						MOV		SI,MSG_READ_DIR
						CALL	TEXT_MESSAGE


						MOV		AH,DISKBIOS_CMD_05H_READ_SECTOR
						MOV		AL,CS:[DISKBIOS_BOOT_DEVICE]
						MOV		DI,ROOTDIR_OFFSET
						INT		93H
						JB		FDBOOT_YSDOS_NOT_FOUND

						; Input
						;   DS:SI	Directory
						;   ES:DI	File name in DOS 8+3 format
						;   DX		Number of files in the directory (including unused directory)
						; Output
						;   CX      Destroyed
						;   DX		0
						;   DF      Clear
						;   CF=0    DS:SI=Found directory entry
						;   CF=1    Not found  SI points to the end of the directory

						; DS is already set.
						MOV		SI,ROOTDIR_OFFSET
						PUSH	CS
						POP		ES
						MOV		DI,YSDOS_SYS_FILENAME
						MOV		DX,FS:[BPB_POS_IN_IPL+BPB_NUM_ROOT_DIR_ENT]
						CALL	SEARCH_DIRECTORY
						JB		FDBOOT_YSDOS_NOT_FOUND

						; Need to know
						;   Where YSDOS.SYS started (LBA)
						;   How many sectors.

						MOV		DI,BPB_POS_IN_IPL

						MOV		EAX,[SI+DIRENT_FILE_SIZE]
						MOVZX	ECX,WORD [DI+BPB_BYTES_PER_SECTOR]

						ADD		EAX,ECX	; For rounding up (+bytesPerSector-1)
						DEC		EAX

						XOR		EDX,EDX
						DIV		ECX

						MOV		EBX,EAX

						; BX is number of sectors.

						MOV		AX,[SI+DIRENT_FIRST_CLUSTER]

						CALL	BPB_CLUSTER_TO_SECT_CT
						POP		DX	; DX will be overwritten by BPB_LBA_TO_CYLINDER_HEAD_SECTOR anyway
						ADD		AX,DX
						POP		DX
						ADD		AX,DX
						CALL	BPB_LBA_TO_CYLINDER_HEAD_SECTOR


						MOV		SI,MSG_FOUND_YSDOS
						CALL	TEXT_MESSAGE


						MOV		DS,CS:[DOSSEG]	; YSDOS Loading Point
						XOR		DI,DI
						MOV		AH,DISKBIOS_CMD_05H_READ_SECTOR
						MOV		AL,CS:[DISKBIOS_BOOT_DEVICE]

						INT		93H
						JB		DISKBIOS_ERROR

						; CF set by INT 93H

						RET

FDBOOT_YSDOS_NOT_FOUND:
						ADD		SP,4
						STC
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LOAD_DOS_FROM_ROM:
						PUSH	CS
						POP		FS
						MOV		DI,ROMDRIVE_BPB

						CALL	BPB_CALC_ROOTDIR_SECT_CT	; In DOSUTIL.NSM  AX is # root-dir sectors, DX destroyed
						MOV		BX,AX
						PUSH	AX	; Save ROOTDIR sector count

						; BX is the number of sectors of the root dir.

						CALL	BPB_CALC_ROOTDIR_LBA		; In DOSUTIL.NSM   BX Preserved
						PUSH	AX	; Save ROOTDIR LBA

						MOV		DX,AX	; DX is ROOTDIR LBA
						XOR		CX,CX	; CX:DX points to ROOTDIR
						MOV		AH,DISKBIOS_CMD_05H_READ_SECTOR
						MOV		AL,DISKBIOS_ROMDISK
						MOV		DI,BOOTSECT_SEG
						MOV		DS,DI
						MOV		DI,ROOTDIR_OFFSET
						INT		93H
						JC		LOAD_DOS_FROM_ROM_NOT_FOUND

						; Input
						;   DS:SI	Directory
						;   ES:DI	File name in DOS 8+3 format
						;   DX		Number of files in the directory (including unused directory)
						; Output
						;   CX      Destroyed
						;   DF      Clear
						;   DX		0
						;   CF=0    DS:SI=Found directory entry
						;   CF=1    Not found  SI points to the end of the directory

						; DS is already set.
						MOV		SI,ROOTDIR_OFFSET
						PUSH	CS
						POP		ES
						MOV		DI,YSDOS_SYS_FILENAME
						MOV		DX,CS:[ROMDRIVE_BPB+BPB_NUM_ROOT_DIR_ENT]
						CALL	SEARCH_DIRECTORY
						JNC		LOAD_DOS_FROM_ROM_FOUND

						MOV		SI,ROOTDIR_OFFSET
						MOV		DI,MSDOS_SYS_FILENAME
						MOV		DX,CS:[ROMDRIVE_BPB+BPB_NUM_ROOT_DIR_ENT]
						CALL	SEARCH_DIRECTORY
						JC		LOAD_DOS_FROM_ROM_NOT_FOUND

LOAD_DOS_FROM_ROM_FOUND:
						MOV		EAX,[SI+DIRENT_FILE_SIZE]
						MOVZX	ECX,WORD CS:[ROMDRIVE_BPB+BPB_BYTES_PER_SECTOR]

						ADD		EAX,ECX	; For rounding up (+bytesPerSector-1)
						DEC		EAX

						XOR		EDX,EDX
						DIV		ECX

						MOV		EBX,EAX

						; BX is number of sectors.

						MOV		AX,[SI+DIRENT_FIRST_CLUSTER]

						MOV		DI,ROMDRIVE_BPB
						CALL	BPB_CLUSTER_TO_SECT_CT ; Preserves BX

						POP		DX	; DX will be overwritten by BPB_LBA_TO_CYLINDER_HEAD_SECTOR anyway
						ADD		AX,DX
						POP		DX
						ADD		DX,AX	; DX is the first sector of MSDOS.SYS
						XOR		CX,CX	; CX:DX is the first sector of MSDOS.SYS

						MOV		DS,CS:[DOSSEG]	; YSDOS Loading Point
						XOR		DI,DI
						MOV		AH,DISKBIOS_CMD_05H_READ_SECTOR
						MOV		AL,DISKBIOS_ROMDISK

						INT		93H

						; CF set by INT 93H

						RET

LOAD_DOS_FROM_ROM_NOT_FOUND:
						ADD		SP,4  ; Skip ROOTDIR LBA and ROOTDIR Sector Count
						STC
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; Input
;   DS:SI	Directory
;   ES:DI	File name in DOS 8+3 format
;   DX		Number of files in the directory (including unused directory)
; Output
;   CX      Destroyed
;   DX		0
;   DF      Clear
;   CF=0    DS:SI=Found directory entry
;   CF=1    Not found  SI points to the end of the directory
SEARCH_DIRECTORY:
						CLD
						PUSH	DI
						PUSH	SI
						MOV		CX,11
						REP		CMPSB
						POP		SI
						POP		DI

						JE		SEARCH_DIR_FOUND

						ADD		SI,DIRENT_LENGTH
						DEC		DX
						JNE		SEARCH_DIRECTORY

						STC
						RET

SEARCH_DIR_FOUND:
						CLC
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FIND_BOOT_DRIVE:
						MOVZX	DX,BYTE CS:[DISKBIOS_BOOT_DEVICE]
						CMP		BYTE CS:[BOOT_DEVICE],BOOTDEV_HD
						JNE		FIND_BOOT_DRIVE_NOT_HD
						MOV		DH,CS:[BOOT_PARTITION]
FIND_BOOT_DRIVE_NOT_HD:

						LGS		SI,CS:[NUM_HD_BPB_PTR]
						MOVZX	CX,GS:[SI]

						LDS		SI,CS:[HD_PARTITION_TABLE_PTR]

FIND_BOOT_DRIVE_LOOP:
						MOV		AL,DS:[SI+DSKDRV_BIOSCODE]
						MOV		AH,DS:[SI+DSKDRV_PARTITION]
						CMP		AX,DX
						JE		FOUND_BOOT_DRIVE

						ADD		SI,DSKDRV_size
						LOOP	FIND_BOOT_DRIVE_LOOP

						XOR		AX,AX	; Nothing I can do
						RET

FOUND_BOOT_DRIVE:
						MOV		AL,DS:[SI+DSKDRV_LETTER]
						SUB		AL,'A'
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FLUSH_KEY_BUFFER:
						MOV		AX,0901H	; AH=09 Read Key  AL=01 No Blocking
						INT		90H
						CMP		DH,0FFH
						JNE		FLUSH_KEY_BUFFER
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

						%INCLUDE	"DOSUTIL.NSM"


%macro					CALL_DISK_BIOS	0
						INT		93H
%endmacro
						%INCLUDE	"ISO9660.NSM"
						%INCLUDE	"PLTDEBUG.NSM"
						%INCLUDE	"CRTC.NSM"
						%INCLUDE	"GRAPHICS.NSM"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


YSDOS_SYS_FILENAME		DB		"YSDOS   SYS"
MSDOS_SYS_FILENAME		DB		"MSDOS   SYS"
YSDOS_SYS_FILENAME_CSTR	DB		"YSDOS.SYS",0

MSG_INT_INITIALIZED		DB		"INT HANDLER READY TO GO",0
MSG_INSTALL_SCSI_CD_FAILED	DB	"SCSI-CD REDIRECTION FAILED",0
MSG_DOS_LOADED			DB		"DOS LOADED",0
MSG_DOSINIT_PASSED		DB		"PASSED DOSINIT",0
MSG_INSTALLING_MSCDEX	DB		"INSTALLING MSCDEX(or SHUCDX)",0
MSG_MSCDEX_INSTALLED	DB		"MSCDEX(or SHUCDX) INSTALLED",0
MSG_DO_CONFIG_SYS		DB		"DO CONFIG.SYS",0
MSG_START_YAMAND_COM	DB		"START YAMAND.COM",0
MSG_RESTORE				DB		"RESTORE",0
MSG_READ_BPB			DB		"READ BPB",0
MSG_READ_DIR			DB		"READ DIR",0
MSG_FOUND_YSDOS			DB		"FOUND YSDOS",0

MSG_ERROR_AX_CX			DB		"ERROR AX=",
MSG_ERROR_AX			DB		"0000 CX=",
MSG_ERROR_CX			DB		"0000",0

DISKBIOS_BOOT_DEVICE	DB		0
BOOT_PARTITION			DB		0		; If booting from HDD

CONDEV_PTR				DD		0

HDD_AUTO_ASSIGN			DB		01h		; 00h Assign drive letters according to the CMOS settings.
										; 01h Automatically assign drive letters, not relying on CMOS.

BOOT_PARTITION_LBA0		DD		0

ROMDRIVE_BPB:			DW		200H	; bytesPerSect
						DB		2		; sectPerCluster
						DW		1		; reservedSectors
						DB		2		; #FATs
						DW		0070H	; #rootDirEntries
						DW		0500H	; #sectors including reserved sectors
						DB		0FBh	; mediaDesc
						DW		2		; #sectPerFAT
						DW		8		; #sectPerTrack
						DW		1		; #heads
						DW		0		; #hiddenSect
						DD		0		; 32-bit #sectors
