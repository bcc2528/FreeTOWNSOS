						%INCLUDE "UTIL.NSM"
						%INCLUDE "DEF.NSM"
						%INCLUDE "TOWNSDEF.NSM"

						CPU		386
						BITS	16


CONFIGSYS_SEG			EQU		0A800h
CONFIGSYS_SIZE_LIMIT	EQU		8000h


CODE					SEGMENT	USE16
						JMP		SHORT REALENTRY

BOOT_DEVICE:			DW		0	; +02h
DOSSEG:					DW		0	; +04h Segment YSDOS.SYS is loaded
BOOT_DRIVE:				DB		0	; +06h
						DB		0
SYSVARS_PTR				DW		0	; +08h
SYSVARS_SEG				DW		0	; +0Ah
CDS_OFFSET				DW		0	; +0Ch

NUM_FILES				DW		15

REALENTRY:
						CALL	CREATE_CDS

						; Save Temporary PDB to a safe location.

						MOV		AH,48h	; ALLOC MEMORY
						MOV		BX,0FFFFh
						INT		21H

						; BX is largest available blocks.

						PUSH	BX

						MOV		AH,48h	; ALLOC MEMORY
						INT		21H

						POP		BX
						PUSH	AX	; Save largest memory chunk

						; AX is the largest memory chunk.

						MOV		ES,AX
						SUB		BX,11H
						MOV		AH,4Ah	; RESIZE MEMORY
						INT 	21H

						MOV		AH,48H	; ALLOC MEMORY
						MOV		BX,10H
						INT		21H

						; AX is 100h bytes memory chunk

						POP		ES	; ES is the largest memory chunk.
						PUSH	AX	; AX is the last 100h bytes before 0C0000h

						MOV		AH,49H	; FREE MEMORY
						INT		21H

						; Must have 100h byte secure memory block at the end of the DOS memory.

						MOV		AH,51H
						INT		21H

						; BX is PSP

						MOV		DS,BX
						XOR		SI,SI

						POP		ES
						PUSH	ES

						XOR		DI,DI

						CLD
						MOV		CX,128
						REP		MOVSW
						MOV		ES:[0036H],ES	; Far Pointer to File Table.

						MOV		BX,ES
						MOV		AH,50H	; SetPSP
						INT		21H

						MOV		DL,CS:[BOOT_DRIVE]
						MOV		AH,0Eh
						INT		21H



						; Towns OS's IO.SYS seems to close file handle 0,1,2,3,4 (STDIN,STDOUT,STDERR,PRN,AUX), and then reopen CON, duplicate twice, and then reopen PRN, and AUX.
						; Why?  I don't know.
						MOV		BX,0
CLOSE_DEFAULT_FILE_LOOP:
						MOV		AH,3EH
						INT		21H
						INC		BX
						CMP		BX,5
						JBE		CLOSE_DEFAULT_FILE_LOOP

						MOV 	AX,3D02H	; OPEN, Mode=02
						MOV		DX,DEFAULT_CONDEV_NAME
						PUSH	CS
						POP		DS
						INT		21H		; Will be assigned to file handle 0 (STDIN)

						MOV		BX,AX
						MOV		AH,45H
						INT		21H		; Will be assigned to file handle 1 (STDOUT)
						MOV		AH,45H
						INT		21H		; Will be assigned to file handle 2 (STDERR)

						MOV		AL,CS:[BOOT_DRIVE]
						ADD		AL,'A'
						MOV		CS:[DEFAULT_COMSPEC],AL
						MOV		CS:[COMMANDCOM_PARAMETER+1],AL

						MOV		CS:[COMMANDCOM_PARAM_SEG],CS

						POP		ES
						MOV		AH,49H	; FREE MEMORY
						INT		21H

						CALL	DO_CONFIG_SYS

						CALL	CREATE_ADDITIONAL_SFT	; Make sure to do it after the preliminary PSP is copied.

						MOV		AX,4B00H	; EXEC
						PUSH	CS
						POP		DS
						MOV		DX,DEFAULT_COMSPEC
						PUSH	CS
						POP		ES
						MOV		BX,COMMANDCOM_PARAMBLOCK
						INT		21H

						HLT
						HLT


DEFAULT_CONDEV_NAME		DB		"CON",0
DEFAULT_COMSPEC			DB		"A:\YAMAND.COM",0

COMMANDCOM_PARAMETER	DB		" A:\ /P",0
COMMANDCOM_PARAMBLOCK	DW		0	; ENVSEG to copy from
						DW		COMMANDCOM_PARAMETER	; Command Tail OFFSET
COMMANDCOM_PARAM_SEG	DW		IOSYS_CS				; Command Tail SEG
						DD		0	; First FCB to be copied
						DD		0	; Second FCB to be copied


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Input AX    = number of pages to push
;       FS:BX = DOS SYSVARS
;
; Preserves FS,BX  No guarantee for other regs
; Destroys DS,ES,SI,DI,DX for sure.
PUSH_MCB:
						MOV		ES,FS:[BX-2]
						PUSH	ES
						POP		DS
						XOR		SI,SI
						MOV		DI,AX
						SHL		DI,4
						MOVSD
						MOVSD
						MOVSD
						MOVSD
						SUB		DI,16

						SUB		ES:[DI+MCB_BLOCK_SIZE],AX
						ADD		FS:[BX-2],AX

						RET


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


CREATE_CDS:
						MOV		AX,IOSYS_CS
						MOV		DS,AX

						LGS		BX,CS:[SYSVARS_PTR]

						LFS		SI,GS:[BX+SYSVARS_FIRST_DPB]

						MOV		DI,CS:[CDS_OFFSET]
						XOR		CL,CL
						MOV		CH,GS:[BX+SYSVARS_NUM_DPB]
CREATE_CDS_LOOP:
						MOV		EAX,05C3A41h	; 41H='A'  3A=':'  5C='\'
						ADD		AL,CL
						MOV		[DI+CDS_CURDIR],EAX
						MOV		WORD [DI+CDS_CURDIR_CLUSTER],0xFFFF
						MOV		WORD [DI+CDS_CURDIR_ROOTLEN],2

						CMP		CL,CH
						JGE		CREATE_CDS_NO_MORE_DPB

						MOV		WORD [DI+CDS_DRIVE_TYPE],CDS_TYPE_VALID
						MOV		[DI+CDS_DRIVE_PARAM_BLOCK],SI
						MOV		[DI+CDS_DRIVE_PARAM_BLOCK+2],FS
						LFS		SI,FS:[SI+DPB_PTR_TO_NEXT_DPB]

CREATE_CDS_NO_MORE_DPB:
						ADD		DI,CURRENT_DIR_STRUCT_size
						INC		CL
						CMP		CL,MAX_NUM_CDS
						JB		CREATE_CDS_LOOP

						MOV		AX,CS:[CDS_OFFSET]
						MOV		WORD GS:[BX+SYSVARS_FIRST_CDS],AX
						MOV		WORD GS:[BX+SYSVARS_FIRST_CDS+2],IOSYS_CS
						MOV		BYTE GS:[BX+SYSVARS_NUM_CDS],MAX_NUM_CDS

						RET


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


CREATE_ADDITIONAL_SFT:
						; Push FIRST_MCB and make FCB there.
						LFS		BX,CS:[SYSVARS_PTR]	; FS:BX is SYSVARS
						MOV		ES,FS:[BX-2]		; ES is First MCB

						MOV		AX,CS:[NUM_FILES]
						MOV		DX,SFT_ENTRY_SIZE
						MUL		DX
						ADD		AX,SFT_HEADER_size+15
						SHR		AX,4

						PUSH	AX
						CALL	PUSH_MCB
						POP		AX

						SHL		AX,4	; DX is the number of bytes aligned to the page border.

						XOR		DI,DI
						MOV		CX,AX
						XOR		AX,AX
						CLD
						REP		STOSB

						MOV		DWORD ES:[0],0FFFFFFFFh
						MOV		AX,CS:[NUM_FILES]
						MOV		ES:[4],AX

						XOR		AX,AX
						MOV		FS:[BX+SYSVARS_SFT],AX
						MOV		FS:[BX+SYSVARS_SFT+2],ES


						RET


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CONFIGSYS_FILENAME		DB		"A:\CONFIG.SYS",0
CONFIGSYS_LENGTH		DW		0

KEYWORD_SHELL			DB		"SHELL"
KEYWORD_SHELL_LENGTH	EQU		7
KEYWORD_DEVICE			DB		"DEVICE"
KEYWORD_DEVICE_LENGTH	EQU		6
KEYWORD_FILES			DB		"FILES"
KEYWORD_FILES_LENGTH	EQU		5

DEVICE_LOAD_POINT		DW		0
						DW		0

DO_CONFIG_SYS:
						CALL	LOAD_CONFIG_SYS
						JC		DO_CONFIG_SYS_EXIT


						LDS		SI,CS:[SYSVARS_PTR]
						MOV		BX,DS:[SI-2]	; First MCB
						INC		BX				; Protect the current MCB.  I waste 16 bytes.
						MOV		CS:[DEVICE_LOAD_POINT],BX
						MOV		CS:[DEVICE_LOAD_POINT+2],BX

						MOV		SI,CONFIGSYS_SEG
						MOV		DS,SI
						XOR		SI,SI

						PUSH	CS
						POP		ES
DO_CONFIG_SYS_LOOP:
						; DS:SI is the CONFIG.SYS pointer.
						CALL	CONFIG_SYS_COUNT_LINE_LENGTH
						; BX is the length of the line

						PUSH	BX

						MOV		BYTE [SI+BX],0	; Terminate the string.
						OR		BX,BX
						JE		DO_CONFIG_SYS_NEXT

						CALL	CONFIGSYS_CAPITALIZE_BEFORE_EQUAL

						PUSH	SI
						MOV		DI,KEYWORD_SHELL
						MOV		CX,KEYWORD_SHELL_LENGTH
						REPE	CMPSB
						POP		SI
						JNE		DO_CONFIG_NOT_SHELL
						CALL	DO_CONFIG_SHELL
						JMP		DO_CONFIG_SYS_NEXT

DO_CONFIG_NOT_SHELL:
						PUSH	SI
						MOV		DI,KEYWORD_DEVICE
						MOV		CX,KEYWORD_DEVICE_LENGTH
						REPE	CMPSB
						POP		SI
						JNE		DO_CONFIG_NOT_DEVICE
						CALL	DO_CONFIG_DEVICE
						JMP		DO_CONFIG_SYS_NEXT

DO_CONFIG_NOT_DEVICE:
						PUSH	SI
						MOV		DI,KEYWORD_FILES
						MOV		CX,KEYWORD_FILES_LENGTH
						REPE	CMPSB
						POP		SI
						JNE		DO_CONFIG_NOT_FILES
						CALL	DO_CONFIG_FILES
						JMP		DO_CONFIG_SYS_NEXT

DO_CONFIG_NOT_FILES:


DO_CONFIG_SYS_NEXT:
						POP		BX
						LEA		SI,[SI+BX+1]
						CMP		SI,CS:[CONFIGSYS_LENGTH]
						JB		DO_CONFIG_SYS_LOOP

DO_CONFIG_SYS_EXIT:
						RET


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DO_CONFIG_SHELL:
						PUSH	DS
						PUSH	SI

						POP		SI
						POP		DS
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DO_CONFIG_DEVICE:
						TSUGARU_DEBUG

						PUSH	DS
						PUSH	SI

						MOV		AX,CS
						MOV		ES,AX

						CALL	CONFIG_SYS_SKIP_EQUAL
						CMP		BYTE [SI-1],'='
						JNE		DO_CONFIG_DEVICE_EXIT

						CALL	CONFIG_SYS_SKIP_SPACE_AND_TAB

						; DS:SI points to the command line.
						MOV		DX,SI	; DS:DX points to the file name.

						CALL	CONFIG_SYS_SKIP_UNTIL_SPACE_AND_TAB
						MOV		BYTE [SI],0

						MOV		AX,4B03H ; LOAD Overlay
						MOV		BX,DEVICE_LOAD_POINT	; Pointer to the device load point and relocation factor

						INT		21H


DO_CONFIG_DEVICE_EXIT:
						POP		SI
						POP		DS
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DO_CONFIG_FILES:
						PUSH	DS
						PUSH	SI

						POP		SI
						POP		DS
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Input DS:SI=Pointer to the line
; Output BX=Line Length
CONFIG_SYS_COUNT_LINE_LENGTH:
						XOR		BX,BX

CONFIG_SYS_COUNT_LINE_LENGTH_LOOP:
						MOV		AL,[SI+BX]
						CMP		AL,0Dh
						JE		CONFIG_SYS_COUNT_LINE_LENGTH_EXIT
						CMP		AL,0Ah
						JE		CONFIG_SYS_COUNT_LINE_LENGTH_EXIT
						OR		AL,AL
						JE		CONFIG_SYS_COUNT_LINE_LENGTH_EXIT
						INC		BX
						JMP		CONFIG_SYS_COUNT_LINE_LENGTH_LOOP

CONFIG_SYS_COUNT_LINE_LENGTH_EXIT:
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Input DS:SI=Pointer to the line
; Output DS:SI=Pointer to after the first '='.  Or, can be end of the command line.
;        AL=Destroyed
CONFIG_SYS_SKIP_EQUAL:
						MOV		AL,[SI]
						CALL	AL_IS_ZERO_CR_OR_LF
						JE		CONFIG_SYS_SKIP_EQUAL_EXIT

						INC		SI
						CMP		AL,'='
						JNE		CONFIG_SYS_SKIP_EQUAL

CONFIG_SYS_SKIP_EQUAL_EXIT:
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Input DS:SI=Pointer to a string.
; Output DS:SI=Pointer to after skipping SPACEs and TABs.  Or, can be end of the command line.
;        AL=Destroyed
CONFIG_SYS_SKIP_SPACE_AND_TAB:
						MOV		AL,[SI]
						CALL	AL_IS_SPACE_OR_TAB
						JNE		CONFIG_SYS_SKIP_SPACE_AND_TAB_EXIT

						INC		SI
						JMP		CONFIG_SYS_SKIP_SPACE_AND_TAB

CONFIG_SYS_SKIP_SPACE_AND_TAB_EXIT:
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Input DS:SI=Pointer to a string.
; Output DS:SI=Pointer to first ' '.  Or, can be end of the command line.
;        AL=Destroyed
CONFIG_SYS_SKIP_UNTIL_SPACE_AND_TAB:
						MOV		AL,[SI]
						CALL	AL_IS_SPACE_OR_TAB
						JE		CONFIG_SYS_SKIP_UNTIL_SPACE_AND_TAB_EXIT

						CALL	AL_IS_ZERO_CR_OR_LF
						JE		CONFIG_SYS_SKIP_UNTIL_SPACE_AND_TAB_EXIT

						INC		SI
						JMP		CONFIG_SYS_SKIP_UNTIL_SPACE_AND_TAB

CONFIG_SYS_SKIP_UNTIL_SPACE_AND_TAB_EXIT:
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Input  AL=ASCII Code
; Output ZF is set if AL is space or tab.
AL_IS_SPACE_OR_TAB:
						CMP		AL,' '
						JE		AL_IS_SPACE_OR_TAB_EXIT
						CMP		AL,TAB

AL_IS_SPACE_OR_TAB_EXIT:
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Input  AL=ASCII Code
; Output ZF is set if AL is space or tab.
AL_IS_ZERO_CR_OR_LF:
						OR		AL,AL
						JE		AL_IS_ZERO_CR_OR_LF_EXIT
						CMP		AL,0DH
						JE		AL_IS_ZERO_CR_OR_LF_EXIT
						CMP		AL,0AH
						JE		AL_IS_ZERO_CR_OR_LF_EXIT

AL_IS_ZERO_CR_OR_LF_EXIT:
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Input  DS:SI=Pointer to the line,  BX=Line Length
; CX destroyed.
CONFIGSYS_CAPITALIZE_BEFORE_EQUAL:
						MOV		CX,BX
						XOR		BX,BX

CONFIGSYS_CAPITALIZE_BEFORE_EQUAL_LOOP:
						MOV		AL,DS:[SI+BX]
						CMP		AL,'='
						JE		CONFIGSYS_CAPITALIZE_BEFORE_EQUAL_EXIT

						AND		AL,0DFh
						MOV		DS:[SI+BX],AL

						INC		BX
						CMP		BX,CX
						JB		CONFIGSYS_CAPITALIZE_BEFORE_EQUAL_LOOP

CONFIGSYS_CAPITALIZE_BEFORE_EQUAL_EXIT:
						MOV		BX,CX
						RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


LOAD_CONFIG_SYS:
						MOV		DX,CONFIGSYS_SEG
						MOV		ES,DX
						CLD
						MOV		CX,CONFIGSYS_SIZE_LIMIT
						XOR		AX,AX
						REP		STOSB

						MOV		AL,CS:[BOOT_DRIVE]
						ADD		AL,'A'
						MOV		CS:[CONFIGSYS_FILENAME],AL

						MOV		AX,3D00h	; FOPEN Normal Mode
						PUSH	CS
						POP		DS
						MOV		DX,CONFIGSYS_FILENAME
						INT		21H
						JB		LOAD_CONFIG_SYS_EXIT

						MOV		BX,AX

						; BX is file handle

						MOV		AH,3FH	; FREAD
						MOV		CX,CONFIGSYS_SIZE_LIMIT
						MOV		DX,CONFIGSYS_SEG
						MOV		DS,DX
						XOR		DX,DX
						INT		21H
						JB		LOAD_CONFIG_SYS_EXIT

						; AX is the number of bytes actually read.
						MOV		CS:[CONFIGSYS_LENGTH],AX

						; BX is still the file handle

						MOV		AH,3EH	; FCLOSE
						INT		21H

LOAD_CONFIG_SYS_EXIT:
						RET
